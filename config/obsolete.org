#+TITLE: 过时的配置和函数
#+DESCRIPTION: 留着给以后做参考

* UI
** Font
#+begin_src emacs-lisp

  (if *is-windows*
      ;; Setting English Font 仅在 windows 生效
      (progn
        (set-face-attribute
         'default nil
         :font "DejaVu Sans Mono for Powerline"
         :height 140)
        ;; Setting Chinese Font
        (set-fontset-font t '(#x4e00 . #x9fff) "Microsoft Yahei")))

  ;; @ref https://emacs-china.org/t/windows-emacs/7907/39
  ;; 下面这个配置当我需要更换其他的字体的时候，加上下面这一行，也可以保证中英文的对齐
  (set-fontset-font "fontset-default" 'unicode'("等距更纱黑体 SC"))
#+end_src

** 光标(cursor)
change-cursor-mode inspired manual solution
#+begin_src emacs-lisp
  (add-hook 'post-command-hook
            (lambda () (if buffer-read-only
                           (setq cursor-type 'box)
                         (setq cursor-type 'bar))))
#+end_src

** Theme
根据时间自动切换主题
#+begin_src emacs-lisp
  ;; autoswitch theme by time
  (let ((hour (string-to-number
               (substring (current-time-string) 11 13))))
    (if (member hour (number-sequence 6 17))
        (load-theme 'modus-operandi t)
      (load-theme 'modus-vivendi t)))
#+end_src

* 函数
** display-line-numbers-cycle
#+begin_src emacs-lisp
  (defvar display-line-numbers-relative-p nil)

  (defun display-line-numbers-cycle ()
    (interactive)
    (if display-line-numbers-relative-p
        (progn (menu-bar--display-line-numbers-mode-absolute)
               (setq display-line-numbers-relative-p nil))
      (menu-bar--display-line-numbers-mode-relative)
      (setq display-line-numbers-relative-p t)))
#+end_src

** next-same-major-mode-buffer
#+begin_src emacs-lisp
  (transient-command next-same-major-mode-buffer
    (next-same-major-mode-buffer)
    '(("m" . next-same-major-mode-buffer)))

  (defun next-same-major-mode-buffer ()
    "Go to next buffer which has same major-mode of current buffer

  this command is useful only when current buffer's major mode is
  `eshell-mode', `eaf-mode', `term-mode', `shell-mode' or other
  special major mode"
    (interactive)
    (let ((current major-mode))
      (catch 'done
        ;; `buffer-list' is changeable variable, the recently visited
        ;; buffer always next to the current buffer, if I do not use
        ;; `reverse', and if there is one buffer having same major mode
        ;; with current buffer, it will back and forth these two buffer,
        ;; despite there potentially are other buffers having the same
        ;; major mode with current buffer.
        (dolist (buf (reverse (cdr (buffer-list))) (message "only one `%s' buffer" current))
          (with-current-buffer buf
            (when (eq current major-mode)
              (throw 'done (progn (switch-to-buffer buf)
                                  (message "next `%s' buffer" current)))))))))
#+end_src

* Ido
#+begin_src emacs-lisp
  ;;TODO：ido-mode 下的 minibuffer-complete 对应的是 ido-complete，所以下面的命令需要重新写一下
  (define-key minibuffer-local-map (kbd "M-i") 'minibuffer-complete)
#+end_src

* Isearch
#+begin_src emacs-lisp
  (defun fei-search-symbol-at-point ()
    (interactive)
    (cond
     ((bounds-of-thing-at-point 'symbol)
      (if ctrlf-local-mode
          (call-interactively 'ctrlf-forward-symbol-at-point)
        (call-interactively 'isearch-forward-symbol-at-point)))
     (t
      (if ctrlf-local-mode
          (ctrlf-forward-default)
        (isearch-forward)))))
#+end_src

#+begin_src emacs-lisp
  (defun fei-search-forward ()
    "这个函数的出现是为了解决 isearch 和 rime 输入冲突的情况"
    (interactive)
    (if (not (string= current-input-method "rime"))
        (call-interactively 'isearch-forward)
      (deactivate-input-method)		; 之所以这里是禁用输入法，是基
                                          ; 于这么一个判断：我用 isearch
                                          ; 更多的时候是用来搜字符，如果
                                          ; 是搜索中文，我有预期要启用输
                                          ; 入法，这也是我的使用习惯导致
                                          ; 的，但是这个思路有引入了另外
                                          ; 一个问题：当中英文字体不是等
                                          ; 高的时候，mode line 就会因为
                                          ; 输入法指示 "ㄓ" 的出现和消失
                                          ; 跳来跳去，当然这个也可以通过
                                          ; 设置 "等距更纱黑体" 字体来解
                                          ; 决。不过我也意识到了：我也不
                                          ; 会很频繁地有这样的操作
      (call-interactively 'isearch-forward)))

  (defun fei-search-backward ()
    "这个函数的出现是为了解决 isearch 和 rime 输入冲突的情况"
    (interactive)
    (if (not (string= current-input-method "rime"))
        (call-interactively 'isearch-backward)
      (deactivate-input-method)
      (call-interactively 'isearch-backward)))
#+end_src

#+begin_src emacs-lisp

  ;; 一个基于 ivy 的很有意思的解决方案，记录备忘一下
  (global-set-key (kbd "C-s") (li (let ((ivy-height 1)) (swiper-isearch))))
#+end_src

* Org-agenda
#+begin_src emacs-lisp
  (when (display-graphic-p)
    (org-agenda nil "a")
    (delete-other-windows))
  (add-hook 'server-after-make-frame-hook
            (lambda () (when window-system
                         (org-agenda nil "a")
                         (delete-other-windows))))
#+end_src

* Matlab
#+begin_src emacs-lisp
  (autoload 'org-ctrl-c-ctrl-c "org" nil t) ; hack for matlab-mode
  (with-eval-after-load 'matlab
    (define-key matlab-mode-map (kbd "C-c C-c") 'org-ctrl-c-ctrl-c))
#+end_src

* Company & Yasnippet
这部分的配置都是抄的 =Centuar Emacs= 的配置，但是当时抄的时候没有怎么弄懂
#+begin_src emacs-lisp
  (with-eval-after-load 'yasnippet
    (with-eval-after-load 'company
      (global-set-key (kbd "M-i") 'company-yasnippet/yas-expand)
      (defun company-yasnippet/yas-expand ()
        (interactive)
        (call-interactively 'company-yasnippet)
        (when (eq 1 company-candidates-length)
          (call-interactively 'yas-expand)))
      ))
#+end_src

#+begin_src emacs-lisp
  (defun my-lsp-fix-company-capf ()
    "Remove redundant `comapny-capf'."
    (setq company-backends
          (remove 'company-backends (remq 'company-capf company-backends))))
  (advice-add #'lsp-completion--enable :after #'my-lsp-fix-company-capf)
#+end_src

#+begin_src emacs-lisp
  (defun my-company-yasnippet-disable-inline (fn cmd &optional arg &rest _ignore)
    "Enable yasnippet but disable it inline."
    (if (eq cmd  'prefix)
        (when-let ((prefix (funcall fn 'prefix)))
          (unless (memq (char-before (- (point) (length prefix)))
                        '(?. ?< ?> ?\( ?\) ?\[ ?{ ?} ?\" ?' ?`))
            prefix))
      (progn
        (when (and (bound-and-true-p lsp-mode)
                   arg (not (get-text-property 0 'yas-annotation-patch arg)))
          (let* ((name (get-text-property 0 'yas-annotation arg))
                 (snip (format "%s (Snippet)" name))
                 (len (length arg)))
            (put-text-property 0 len 'yas-annotation snip arg)
            (put-text-property 0 len 'yas-annotation-patch t arg)))
        (funcall fn cmd  arg))))
  (advice-add #'company-yasnippet :around #'my-company-yasnippet-disable-inline)
#+end_src

#+begin_src emacs-lisp
  (defun my-company-yasnippet ()
    "Hide the current completeions and show snippets."
    (interactive)
    (company-cancel)
    (call-interactively 'company-yasnippet))
#+end_src

这一段代码是抄的 lazycat-emacs 的配置
#+begin_src emacs-lisp
  ;; `yasnippet' integration
  (with-no-warnings
    (with-eval-after-load 'yasnippet
      (defun company-backend-with-yas (backend)
        "Add `yasnippet' to company backend."
        (if (and (listp backend) (member 'company-yasnippet backend))
            backend
          (append (if (consp backend) backend (list backend))
                  '(:with company-yasnippet))))

      (defun my-company-enbale-yas (&rest _)
        "Enable `yasnippet' in `company'."
        (setq company-backends (mapcar #'company-backend-with-yas company-backends)))
      ))
#+end_src
* Tab Bar
#+begin_src emacs-lisp
  (transient-command tab-next
    (tab-next)
    '(("o" . tab-next)
      ("O" . tab-previous)))

  (transient-command tab-previous
    (tab-previous)
    '(("o" . tab-next)
      ("O" . tab-previous)))
#+end_src

* Misc
#+begin_src emacs-lisp
  ;; 此配置配合`auto-save'避免写在*scratch*中的内容未保存导致的数据丢失
  (add-hook 'after-init-hook
            (lambda ()
              (find-file "~/.emacs.d/@scratch@")
              ;; (setq initial-buffer-choice "~/.emacs.d/@scratch@")
              (kill-buffer "*scratch*")))
#+end_src

这里的归因是当时写的，不一定正确。
#+begin_src emacs-lisp

  ;; 此设置会导致一个小问题：blink 一下当前行之后高亮不清除。主要表现在
  ;; thing-edit 和 citre 这两个插件上，都会出现高亮后高亮区域不消失的情况

  ;; 此设置在笔记本电脑上面会出现画面透明的问题，找到问题了：是桌面特效
  ;; 的bug，不过是启动Emacs的时候有问题，别的应用也会出现消失不见的问题

  (setq frame-resize-pixelwise t)
#+end_src

关闭 backup 功能，即不生成 =~= 后缀文件
#+begin_src emacs-lisp
  (setq make-backup-files nil)
#+end_src

* Eshell
#+begin_src emacs-lisp
  (add-hook 'eshell-mode-hook
            (lambda ()
              (define-key eshell-mode-map (kbd "C-l") (lambda () (interactive) (recenter 0)))))
  ;; another workaround
  (add-hook 'eshell-mode-hook
            (lambda ()
              (setq-local recenter-positions '(top middle bottom))))
#+end_src

#+begin_src emacs-lisp
  ;; @REF https://www.emacswiki.org/emacs/EshellAutojump
  (defun eshell/j (&rest args)
    "Jump to a directory you often cd to.
  This compares the argument with the list of directories you usually jump to.
  Without an argument, list the ten most common directories.
  With a positive integer argument, list the n most common directories.
  Otherwise, call `eshell/cd' with the result."
    (setq args (eshell-flatten-list args))
    (let ((arg (or (car args) 10))
          (map (make-hash-table :test 'equal))
          (case-fold-search (eshell-under-windows-p))
          candidates
          result)
      ;; count paths in the ring and produce a map
      (dolist (dir (ring-elements eshell-last-dir-ring))
        (if (gethash dir map)
            (puthash dir (1+ (gethash dir map)) map)
          (puthash dir 1 map)))
      ;; use the map to build a sorted list of candidates
      (maphash (lambda (key value)
                 (setq candidates (cons key candidates)))
               map)
      (setq candidates (sort candidates
                             (lambda (a b)
                               (> (gethash a map)
                                  (gethash b map)))))
      ;; list n candidates or jump to most popular candidate
      (if (and (integerp arg) (> arg 0))
          (progn
            (let ((n (nthcdr (1- arg) candidates)))
              (when n
                (setcdr n nil)))
            (eshell-lisp-command
             (mapconcat (lambda (s)
                          (format "%4d %s" (gethash s map) s))
                        candidates "\n")))
        (while (and candidates (not result))
          (if (string-match arg (car candidates))
              (setq result (car candidates))
            (setq candidates (cdr candidates))))
        (eshell/cd result))))
#+end_src

#+begin_src emacs-lisp
  (defun eshell/bash ()
    (interactive)
    (ansi-term (executable-find "bash")))
#+end_src

* Term
“遍历--中断” 示例代码
#+begin_src emacs-lisp
  (defun goto-term ()
    (interactive)
    (catch 'done
      (dolist (buf (buffer-list))
        (with-current-buffer buf
          (when (eq major-mode 'term-mode)
            (throw 'done (switch-to-buffer buf)))))))
#+end_src

* LaTeX
#+begin_src emacs-lisp
  (setq TeX-view-program-selection
        '(((output-dvi has-no-display-manager)
           "dvi2tty")
          ((output-dvi style-pstricks)
           "dvips and gv")
          (output-dvi "xdvi")
          (output-pdf "Zathura")
          (output-html "xdg-open")))
#+end_src

* Dired
#+begin_src emacs-lisp
  (defun find-name-current-dired (arg)
    (interactive
     (let ((string
            (read-string "Find-name(filename wildcard): " nil 'history)))
       (list string)))
    (find-name-dired "." arg))
#+end_src

* Tab-line
#+begin_src emacs-lisp
  ;; 此配置有 bug
  ;;
  ;; 复现步骤：
  ;; 1. 打开 eshell 运行 tmux
  ;; 2. 然后在打开 ansi-term 之后 term-raw-map 中就没有 C-c 开头的快捷键了，此时 C-c => term-send-raw
  (add-hook 'term-mode-hook
            (lambda ()
              (define-key term-raw-map (kbd "C-c ,") 'transient-tab-line-prev)
              (define-key term-raw-map (kbd "C-c .") 'transient-tab-line-next)))
#+end_src

* Edit
#+begin_src emacs-lisp
  (defun fei-newline ()
    (interactive)
    (end-of-line)
    (newline-and-indent))
#+end_src

#+begin_src emacs-lisp
  (global-set-key (kbd "M-N") 'transient-scroll-up-line)
  (global-set-key (kbd "M-P") 'transient-scroll-down-line)

  (transient-command scroll-up-line
    (call-interactively 'scroll-up-line)
    '(("n" . scroll-up-line)
      ("p" . scroll-down-line)))

  (transient-command scroll-down-line
    (call-interactively 'scroll-down-line)
    '(("n" . scroll-up-line)
      ("p" . scroll-down-line)))
#+end_src

#+begin_src emacs-lisp
  ;; @see https://www.emacswiki.org/emacs/CopyingWholeLines
  ;; duplicate current line
  (defun duplicate-current-line (&optional n)
    "duplicate current line, make more than 1 copy given a numeric argument"
    (interactive "p")
    (save-excursion
      (let ((nb (or n 1))
            (current-line (thing-at-point 'line)))
        ;; when on last line, insert a newline first
        (when (= 1 (forward-line 1))
          (insert "\n"))
      
        ;; now insert as many time as requested
        (while (> n 0)
          (insert current-line)
          (decf n)))))
#+end_src

#+begin_src emacs-lisp
  (defun back-to-indentation-or-beginning () (interactive)
         (if (= (point) (progn (back-to-indentation) (point)))
             (beginning-of-line)))
#+end_src

<C-M-backspace> 在系统层面绑定了 kill xorg 命令
#+begin_src emacs-lisp
  (global-set-key (kbd "<C-M-backspace>") 'backward-kill-sexp)
#+end_src

* Evil
evil-mode 偶尔才会用一下，没有必要搞一个快捷键。

#+begin_src emacs-lisp
  (global-set-key (kbd "C-S-z") 'evil-mode-with-cursor)
  (define-key evil-normal-state-map (kbd "C-S-z") 'evil-mode-with-cursor)
  (define-key evil-insert-state-map (kbd "C-S-z") 'evil-mode-with-cursor)
  (define-key evil-visual-state-map (kbd "C-S-z") 'evil-mode-with-cursor)
  (define-key evil-motion-state-map (kbd "C-S-z") 'evil-mode-with-cursor)
  (define-key evil-emacs-state-map (kbd "C-S-z") 'evil-mode-with-cursor)
  (setq evil-emacs-state-cursor 'bar)
#+end_src

* Rime
还不知道是什么原因，下面的设置不能生效，保留是为了下次想追究方便回忆

这段代码是想要配置选中的项的高亮配色
#+begin_src emacs-lisp
  (set-face-attribute 'rime-default-face nil :slant 'italic)
#+end_src

** rime mode line indicator 自己魔改的版本
#+begin_src emacs-lisp
  (with-eval-after-load 'rime
    ;; 下面的设置会覆盖默认信息，但我只是想添加这个指示信息，便有了
    ;; `fei-rime-lighter'，

    ;; (setq mode-line-mule-info '((:eval (rime-lighter))))

    (add-to-list 'mode-line-mule-info '((:eval (fei-rime-lighter))))
    (setq-default mode-line-mule-info mode-line-mule-info)

    (defun fei-rime-lighter ()
      "rewrite `rime-lighter' "
      (if (and (equal current-input-method "rime")
               (bound-and-true-p rime-mode))
          (if (and (rime--should-enable-p)
                   (not (rime--should-inline-ascii-p)))
              (propertize
               (char-to-string 12563)
               'face
               'rime-indicator-face)
            (propertize
             (char-to-string 12563)
             'face
             'rime-indicator-dim-face))
        ""))
    )
#+end_src

* EAF
#+begin_src emacs-lisp
  (defun fei-eaf-start ()
    (interactive)
    (use-package eaf
      :init
      (use-package epc :defer t :ensure t)
      (use-package ctable :defer t :ensure t)
      (use-package deferred :defer t :ensure t)
      (use-package s :defer t :ensure t)))
#+end_src

* Keybindings
#+begin_src emacs-lisp
  (with-eval-after-load 'matlab-mode
    (define-key matlab-mode-map (kbd "M-j") 'ivy-switch-buffer))

  (global-set-key (kbd "M-j") 'ivy-switch-buffer)

  (define-key ivy-minibuffer-map (kbd "M-j") (kbd "RET"))
  (define-key minibuffer-local-map (kbd "M-j") (kbd "RET"))
  (define-key minibuffer-local-map (kbd "M-h") (kbd "RET"))
#+end_src

* Ibuffer
后来发现 ibuffer 一点也不常用
#+begin_src emacs-lisp
  (global-set-key (kbd "C-x C-b") (li (ibuffer-jump) (ibuffer-auto-mode 1)))
  (global-set-key (kbd "C-x 4 C-b") (li (ibuffer-jump t) (ibuffer-auto-mode 1)))
#+end_src

* Windows
#+begin_src emacs-lisp
  (transient-command other-window-backward
    (other-window-backward)
    '(("o" . other-window)
      ("O" . other-window-backward)))
#+end_src

* Octave
#+begin_src emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.m\\'" . octave-mode))

  (add-hook 'octave-mode-hook
            (lambda ()
              (progn
                (setq octave-comment-char ?%)
                (setq comment-start "% ")
                (setq comment-add 0)
                (setq comment-column 0)
                )))
#+end_src

* Ivy-posframe
设置 ivy 相关的窗口显示的位置
#+begin_src emacs-lisp
  (ivy-posframe-mode 1)

  (setq ivy-posframe-display-functions-alist
      '((t . ivy-posframe-display-at-frame-top-center)
        ))

  ;; (setq ivy-posframe-display-functions-alist
  ;;     '((swiper . ivy-posframe-display-at-frame-bottom-window-center)
  ;;       (complete-symbol . ivy-posframe-display-at-point)
  ;;       (counsel-M-x . ivy-posframe-display-at-frame-center)
  ;;       (counsel-find-file . ivy-posframe-display-at-frame-center)
  ;;       (ivy-switch-buffer . ivy-posframe-display-at-frame-center)))
#+end_src

