#+TITLE: 过时的配置和函数
#+STARTUP: overview
#+DESCRIPTION: 留着给以后做参考

* Engine
#+BEGIN_SRC emacs-lisp
  (add-to-list 'load-path "~/.emacs.d/extensions/one-key")
  (require 'one-key)

  (one-key-create-menu
   "ENGINE"
   '(
     (("g" . "谷歌") . engine/search-google)
     (("z" . "知乎") . engine/search-zhihu)
     (("h" . "Github") . engine/search-github)
     (("b" . "哔哩哔哩") . engine/search-bilibili)
     (("d" . "DuckDuckGo") . engine/search-duckduckgo)
     (("D" . "百度") . engine/search-baidu)
     (("B" . "必应") . engine/search-bing)
     (("S" . "搜狗") . engine/search-sogou)
     (("y" . "YouTube") . engine/search-youtube)
     (("s" . "谷歌学术") . engine/search-google-scholar)
     (("i" . "谷歌图片") . engine/search-google-images)
     (("c" . "必应词典") . engine/search-bing-dict)
     (("q" . "Qwant") . engine/search-qwant)
     )
   t)

  (global-set-key (kbd "M-s-g") 'one-key-menu-engine)
#+END_SRC

* Mouse
#+BEGIN_SRC emacs-lisp

  ;; ==== Mode Line ====

  ;FIXME: 按键的平台差异
  (global-set-key (kbd "<mode-line> <mouse-5>") 'scroll-up-line)
  (global-set-key (kbd "<mode-line> <mouse-4>") 'scroll-down-line)
  (global-set-key (kbd "<mode-line> <mouse-9>") 'beginning-of-buffer)
  (global-set-key (kbd "<mode-line> <mouse-8>") 'end-of-buffer)

  ;; ==== Fringe ====

  ;FIXME: 按键的平台差异
  (global-set-key (kbd "<right-fringe> <mouse-4>") 'scroll-down-line)
  (global-set-key (kbd "<right-fringe> <mouse-5>") 'scroll-up-line)
  (global-set-key (kbd "<right-fringe> <mouse-9>") 'beginning-of-buffer)
  (global-set-key (kbd "<right-fringe> <mouse-8>") 'end-of-buffer)

#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; 切换 Buffer
  (global-set-key (kbd "<mouse-9>") 'next-buffer)
  (global-set-key (kbd "<mouse-8>") 'previous-buffer)

  ;; copy / replace
  (global-set-key (kbd "<mouse-9>") 'thing-copy-symbol)
  (global-set-key (kbd "<mouse-8>") 'thing-replace-symbol)
#+END_SRC

* UI
** Font
#+BEGIN_SRC emacs-lisp
  (if *is-windows*
      ;; Setting English Font 仅在 windows 生效
      (progn
        (set-face-attribute
         'default nil
         :font "DejaVu Sans Mono for Powerline"
         :height 140)
        ;; Setting Chinese Font
        (set-fontset-font t '(#x4e00 . #x9fff) "Microsoft Yahei")))

  ;; @ref https://emacs-china.org/t/windows-emacs/7907/39
  ;; 下面这个配置当我需要更换其他的字体的时候，加上下面这一行，也可以保证中英文的对齐
  (set-fontset-font "fontset-default" 'unicode'("等距更纱黑体 SC"))
#+END_SRC

** 光标(cursor)
change-cursor-mode inspired manual solution
#+BEGIN_SRC emacs-lisp
  (add-hook 'post-command-hook
            (lambda () (if buffer-read-only
                           (setq cursor-type 'box)
                         (setq cursor-type 'bar))))
#+END_SRC

** Theme
根据时间自动切换主题
#+BEGIN_SRC emacs-lisp
  ;; autoswitch theme by time
  (let ((hour (string-to-number
               (substring (current-time-string) 11 13))))
    (if (member hour (number-sequence 6 17))
        (load-theme 'modus-operandi t)
      (load-theme 'modus-vivendi t)))
#+END_SRC

* 过时函数
** display-line-numbers-cycle
#+BEGIN_SRC emacs-lisp
  (defvar display-line-numbers-relative-p nil)

  (defun display-line-numbers-cycle ()
    (interactive)
    (if display-line-numbers-relative-p
        (progn (menu-bar--display-line-numbers-mode-absolute)
               (setq display-line-numbers-relative-p nil))
      (menu-bar--display-line-numbers-mode-relative)
      (setq display-line-numbers-relative-p t)))
#+END_SRC

** next-same-major-mode-buffer
#+BEGIN_SRC emacs-lisp

  (defun next-same-major-mode-buffer ()
    "Go to next buffer which has same major-mode of current buffer

  this command is useful only when current buffer's major mode is
  `eshell-mode', `eaf-mode', `term-mode', `shell-mode' or other
  special major mode"
    (interactive)
    (let ((current major-mode))
      (catch 'done
        ;; `buffer-list' is changeable variable, the recently visited
        ;; buffer always next to the current buffer, if I do not use
        ;; `reverse', and if there is one buffer having same major mode
        ;; with current buffer, it will back and forth these two buffer,
        ;; despite there potentially are other buffers having the same
        ;; major mode with current buffer.
        (dolist (buf (reverse (cdr (buffer-list))) (message "only one `%s' buffer" current))
          (with-current-buffer buf
            (when (eq current major-mode)
              (throw 'done (progn (switch-to-buffer buf)
                                  (message "next `%s' buffer" current)))))))))
#+END_SRC

* Ido
#+BEGIN_SRC emacs-lisp
  ;;TODO：ido-mode 下的 minibuffer-complete 对应的是 ido-complete，所以下面的命令需要重新写一下
  (define-key minibuffer-local-map (kbd "M-i") 'minibuffer-complete)
#+END_SRC

* Isearch
#+BEGIN_SRC emacs-lisp
  (defun fei-search-symbol-at-point ()
    (interactive)
    (cond
     ((bounds-of-thing-at-point 'symbol)
      (if ctrlf-local-mode
          (call-interactively 'ctrlf-forward-symbol-at-point)
        (call-interactively 'isearch-forward-symbol-at-point)))
     (t
      (if ctrlf-local-mode
          (ctrlf-forward-default)
        (isearch-forward)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun fei-search-forward ()
    "这个函数的出现是为了解决 isearch 和 rime 输入冲突的情况"
    (interactive)
    (if (not (string= current-input-method "rime"))
        (call-interactively 'isearch-forward)
      (deactivate-input-method)		; 之所以这里是禁用输入法，是基
                                          ; 于这么一个判断：我用 isearch
                                          ; 更多的时候是用来搜字符，如果
                                          ; 是搜索中文，我有预期要启用输
                                          ; 入法，这也是我的使用习惯导致
                                          ; 的，但是这个思路有引入了另外
                                          ; 一个问题：当中英文字体不是等
                                          ; 高的时候，mode line 就会因为
                                          ; 输入法指示 "ㄓ" 的出现和消失
                                          ; 跳来跳去，当然这个也可以通过
                                          ; 设置 "等距更纱黑体" 字体来解
                                          ; 决。不过我也意识到了：我也不
                                          ; 会很频繁地有这样的操作
      (call-interactively 'isearch-forward)))

  (defun fei-search-backward ()
    "这个函数的出现是为了解决 isearch 和 rime 输入冲突的情况"
    (interactive)
    (if (not (string= current-input-method "rime"))
        (call-interactively 'isearch-backward)
      (deactivate-input-method)
      (call-interactively 'isearch-backward)))
#+END_SRC

#+BEGIN_SRC emacs-lisp

  ;; 一个基于 ivy 的很有意思的解决方案，记录备忘一下
  (global-set-key (kbd "C-s") (li (let ((ivy-height 1)) (swiper-isearch))))
#+END_SRC

* Org-agenda
#+BEGIN_SRC emacs-lisp
  (when (display-graphic-p)
    (org-agenda nil "a")
    (delete-other-windows))
  (add-hook 'server-after-make-frame-hook
            (lambda () (when window-system
                         (org-agenda nil "a")
                         (delete-other-windows))))
#+END_SRC

* Matlab
#+BEGIN_SRC emacs-lisp
  (autoload 'org-ctrl-c-ctrl-c "org" nil t) ; hack for matlab-mode
  (with-eval-after-load 'matlab
    (define-key matlab-mode-map (kbd "C-c C-c") 'org-ctrl-c-ctrl-c))
#+END_SRC

* Company & Yasnippet
之前抄的 karthink 的配置在会用到 backquote-change ，结果是会破坏undo，
现在用 # type:command 的方式就不会出现 undo 逻辑的问题了，所以下面的配
置就不需要了
#+BEGIN_SRC emacs-lisp
(use-package warnings
  :config
  (push '(yasnippet backquote-change) warning-suppress-types))
#+END_SRC

这部分的配置都是抄的 =Centuar Emacs= 的配置，但是当时抄的时候没有怎么弄懂
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'yasnippet
    (with-eval-after-load 'company
      (global-set-key (kbd "M-i") 'company-yasnippet/yas-expand)
      (defun company-yasnippet/yas-expand ()
        (interactive)
        (call-interactively 'company-yasnippet)
        (when (eq 1 company-candidates-length)
          (call-interactively 'yas-expand)))
      ))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun my-lsp-fix-company-capf ()
    "Remove redundant `comapny-capf'."
    (setq company-backends
          (remove 'company-backends (remq 'company-capf company-backends))))
  (advice-add #'lsp-completion--enable :after #'my-lsp-fix-company-capf)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun my-company-yasnippet-disable-inline (fn cmd &optional arg &rest _ignore)
    "Enable yasnippet but disable it inline."
    (if (eq cmd  'prefix)
        (when-let ((prefix (funcall fn 'prefix)))
          (unless (memq (char-before (- (point) (length prefix)))
                        '(?. ?< ?> ?\( ?\) ?\[ ?{ ?} ?\" ?' ?`))
            prefix))
      (progn
        (when (and (bound-and-true-p lsp-mode)
                   arg (not (get-text-property 0 'yas-annotation-patch arg)))
          (let* ((name (get-text-property 0 'yas-annotation arg))
                 (snip (format "%s (Snippet)" name))
                 (len (length arg)))
            (put-text-property 0 len 'yas-annotation snip arg)
            (put-text-property 0 len 'yas-annotation-patch t arg)))
        (funcall fn cmd  arg))))
  (advice-add #'company-yasnippet :around #'my-company-yasnippet-disable-inline)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun my-company-yasnippet ()
    "Hide the current completeions and show snippets."
    (interactive)
    (company-cancel)
    (call-interactively 'company-yasnippet))
#+END_SRC

这一段代码是抄的 lazycat-emacs 的配置
#+BEGIN_SRC emacs-lisp
  ;; `yasnippet' integration
  (with-no-warnings
    (with-eval-after-load 'yasnippet
      (defun company-backend-with-yas (backend)
        "Add `yasnippet' to company backend."
        (if (and (listp backend) (member 'company-yasnippet backend))
            backend
          (append (if (consp backend) backend (list backend))
                  '(:with company-yasnippet))))

      (defun my-company-enbale-yas (&rest _)
        "Enable `yasnippet' in `company'."
        (setq company-backends (mapcar #'company-backend-with-yas company-backends)))
      ))
#+END_SRC
* Tab Bar
#+BEGIN_SRC emacs-lisp
  (transient-command tab-next
    (tab-next)
    '(("o" . tab-next)
      ("O" . tab-previous)))

  (transient-command tab-previous
    (tab-previous)
    '(("o" . tab-next)
      ("O" . tab-previous)))
#+END_SRC

* Misc
#+BEGIN_SRC emacs-lisp
  ;; experiments
  (setq auto-hscroll-mode 'current-line)	;设置成 current-line 的时候，鼠标点的时候会抽风，不好用
  (setq auto-hscroll-mode 't)
  (setq hscroll-step 2)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun load-path-add (dir)
    (add-to-list 'load-path dir))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; @REF: https://christiantietze.de/posts/2021/06/emacs-center-window-single-function/
  (defun my/frame-recenter (&optional frame)
    "Center FRAME on the screen.
  FRAME can be a frame name, a terminal name, or a frame.
  If FRAME is omitted or nil, use currently selected frame."
    (interactive)
    (unless (eq 'maximised (frame-parameter nil 'fullscreen))
      (let* ((frame (or (and (boundp 'frame)
			      frame)
			(selected-frame)))
	     (frame-w (frame-pixel-width frame))
	     (frame-h (frame-pixel-height frame))
	     ;; frame-monitor-workarea returns (x y width height) for the monitor
	     (monitor-w (nth 2 (frame-monitor-workarea frame)))
	     (monitor-h (nth 3 (frame-monitor-workarea frame)))
	     (center (list (/ (- monitor-w frame-w) 2)
			   (/ (- monitor-h frame-h) 2))))
	(apply 'set-frame-position (flatten-list (list frame center))))))
  (add-hook 'after-make-frame-functions #'my/frame-recenter)
#+END_SRC

从其他人配置中抄过来的，不知道有什么用
#+BEGIN_SRC emacs-lisp
  (setq split-width-threshold nil)        ;分屏的时候使用上下分屏
  (setq split-height-threshold nil)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; 此配置配合`auto-save'避免写在*scratch*中的内容未保存导致的数据丢失
  (add-hook 'after-init-hook
            (lambda ()
              (find-file "~/.emacs.d/@scratch@")
              ;; (setq initial-buffer-choice "~/.emacs.d/@scratch@")
              (kill-buffer "*scratch*")))
#+END_SRC

这里的归因是当时写的，不一定正确。
#+BEGIN_SRC emacs-lisp

  ;; 此设置会导致一个小问题：blink 一下当前行之后高亮不清除。主要表现在
  ;; thing-edit 和 citre 这两个插件上，都会出现高亮后高亮区域不消失的情况

  ;; 此设置在笔记本电脑上面会出现画面透明的问题，找到问题了：是桌面特效
  ;; 的bug，不过是启动Emacs的时候有问题，别的应用也会出现消失不见的问题

  (setq frame-resize-pixelwise t)
#+END_SRC

关闭 backup 功能，即不生成 =~= 后缀文件
#+BEGIN_SRC emacs-lisp
  (setq make-backup-files nil)
#+END_SRC

* Eshell
next-eshell-buffer
#+BEGIN_SRC emacs-lisp
  ;; @ref https://github.com/manateelazycat/lazycat-emacs/blob/master/site-lisp/extensions/lazycat/basic-toolkit.el line 492
  (defvar num-of-eshell 0)
  (defun next-eshell-buffer (&optional want-to-create)
    "dwim create or switch eshell buffer"
    (interactive "P")
    (cond ((eq want-to-create '-)
           (fei-eshell-cd-here))
          (want-to-create
           (call-interactively 'eshell)
           (setq num-of-eshell (1+ num-of-eshell)))
          ((<= num-of-eshell 0)
           (setq num-of-eshell (1+ num-of-eshell))
           (call-interactively 'eshell))
          (t
           (catch 'done
             (dolist (buf (cdr (buffer-list)))
               (with-current-buffer buf
                 (when (eq major-mode 'eshell-mode)
                   (throw 'done (switch-to-buffer buf)))))))
          ))

  (add-hook 'kill-buffer-query-functions #'sync-num-of-eshell 90)	;90 保证 `sync-num-of-eshell' 在列表的最后面

  (defun sync-num-of-eshell ()
    (if (eq major-mode 'eshell-mode)
        (setq num-of-eshell (- num-of-eshell 1))
      t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (add-hook 'eshell-mode-hook
            (lambda ()
              (define-key eshell-mode-map (kbd "C-l") (lambda () (interactive) (recenter 0)))))
  ;; another workaround
  (add-hook 'eshell-mode-hook
            (lambda ()
              (setq-local recenter-positions '(top middle bottom))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; @REF https://www.emacswiki.org/emacs/EshellAutojump
  (defun eshell/j (&rest args)
    "Jump to a directory you often cd to.
  This compares the argument with the list of directories you usually jump to.
  Without an argument, list the ten most common directories.
  With a positive integer argument, list the n most common directories.
  Otherwise, call `eshell/cd' with the result."
    (setq args (eshell-flatten-list args))
    (let ((arg (or (car args) 10))
          (map (make-hash-table :test 'equal))
          (case-fold-search (eshell-under-windows-p))
          candidates
          result)
      ;; count paths in the ring and produce a map
      (dolist (dir (ring-elements eshell-last-dir-ring))
        (if (gethash dir map)
            (puthash dir (1+ (gethash dir map)) map)
          (puthash dir 1 map)))
      ;; use the map to build a sorted list of candidates
      (maphash (lambda (key value)
                 (setq candidates (cons key candidates)))
               map)
      (setq candidates (sort candidates
                             (lambda (a b)
                               (> (gethash a map)
                                  (gethash b map)))))
      ;; list n candidates or jump to most popular candidate
      (if (and (integerp arg) (> arg 0))
          (progn
            (let ((n (nthcdr (1- arg) candidates)))
              (when n
                (setcdr n nil)))
            (eshell-lisp-command
             (mapconcat (lambda (s)
                          (format "%4d %s" (gethash s map) s))
                        candidates "\n")))
        (while (and candidates (not result))
          (if (string-match arg (car candidates))
              (setq result (car candidates))
            (setq candidates (cdr candidates))))
        (eshell/cd result))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun eshell/bash ()
    (interactive)
    (ansi-term (executable-find "bash")))
#+END_SRC

* Term
“遍历--中断” 示例代码
#+BEGIN_SRC emacs-lisp
  (defun goto-term ()
    (interactive)
    (catch 'done
      (dolist (buf (buffer-list))
        (with-current-buffer buf
          (when (eq major-mode 'term-mode)
            (throw 'done (switch-to-buffer buf)))))))
#+END_SRC

* LaTeX
#+BEGIN_SRC emacs-lisp
  (setq TeX-view-program-selection
        '(((output-dvi has-no-display-manager)
           "dvi2tty")
          ((output-dvi style-pstricks)
           "dvips and gv")
          (output-dvi "xdvi")
          (output-pdf "Zathura")
          (output-html "xdg-open")))
#+END_SRC

* Dired
#+BEGIN_SRC emacs-lisp
  (defun find-name-current-dired (arg)
    (interactive
     (let ((string
            (read-string "Find-name(filename wildcard): " nil 'history)))
       (list string)))
    (find-name-dired "." arg))
#+END_SRC

* Tab-line
#+BEGIN_SRC emacs-lisp

  (transient-command tab-line-next
    (call-interactively 'tab-line-switch-to-next-tab)
    '(("<left>" . tab-line-switch-to-prev-tab)
      ("<right>" . tab-line-switch-to-next-tab)
      ("<down>" . bury-buffer)
      ))

  (transient-command tab-line-prev
    (call-interactively 'tab-line-switch-to-prev-tab)
    '(("<left>" . tab-line-switch-to-prev-tab)
      ("<right>" . tab-line-switch-to-next-tab)
      ("<down>" . bury-buffer)
      ))

  (transient-command last-buffer
    (call-interactively 'fei-meow-last-buffer)
    '(("b" . switch-to-buffer)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; 此配置有 bug
  ;;
  ;; 复现步骤：
  ;; 1. 打开 eshell 运行 tmux
  ;; 2. 然后在打开 ansi-term 之后 term-raw-map 中就没有 C-c 开头的快捷键了，此时 C-c => term-send-raw
  (add-hook 'term-mode-hook
            (lambda ()
              (define-key term-raw-map (kbd "C-c ,") 'transient-tab-line-prev)
              (define-key term-raw-map (kbd "C-c .") 'transient-tab-line-next)))
#+END_SRC

* Edit
这个选项在大多数情况下很带来比较好的结果：可以用 tab 键做更多的事情，而且操作符合 bash 中习惯。但最近发现了一些问题：在 org 中使用 yasnippet ，如 <sh 这个 snippets 。按 tab 键的时候，它总是给我提供一个补全选项，调用的是 ivy overlay 的补全窗口。而且此时按 C-g 取消后，就看不到光标了。必须把当前 buffer 关闭再打开才能重新看到光标。

影响范围挺大的，暂时弃用了。
#+BEGIN_SRC emacs-lisp
  (setq tab-always-indent 'complete)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-a") 'beginning-of-defun)
  (global-set-key (kbd "M-e") 'end-of-defun)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun fei-newline ()
    (interactive)
    (end-of-line)
    (newline-and-indent))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-N") 'transient-scroll-up-line)
  (global-set-key (kbd "M-P") 'transient-scroll-down-line)

  (transient-command scroll-up-line
    (call-interactively 'scroll-up-line)
    '(("n" . scroll-up-line)
      ("p" . scroll-down-line)))

  (transient-command scroll-down-line
    (call-interactively 'scroll-down-line)
    '(("n" . scroll-up-line)
      ("p" . scroll-down-line)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  ;; @see https://www.emacswiki.org/emacs/CopyingWholeLines
  ;; duplicate current line
  (defun duplicate-current-line (&optional n)
    "duplicate current line, make more than 1 copy given a numeric argument"
    (interactive "p")
    (save-excursion
      (let ((nb (or n 1))
            (current-line (thing-at-point 'line)))
        ;; when on last line, insert a newline first
        (when (= 1 (forward-line 1))
          (insert "\n"))
      
        ;; now insert as many time as requested
        (while (> n 0)
          (insert current-line)
          (decf n)))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (defun back-to-indentation-or-beginning () (interactive)
         (if (= (point) (progn (back-to-indentation) (point)))
             (beginning-of-line)))
#+END_SRC

<C-M-backspace> 在系统层面绑定了 kill xorg 命令
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "<C-M-backspace>") 'backward-kill-sexp)
#+END_SRC

* Evil
evil-mode 偶尔才会用一下，没有必要搞一个快捷键。

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-S-z") 'evil-mode-with-cursor)
  (define-key evil-normal-state-map (kbd "C-S-z") 'evil-mode-with-cursor)
  (define-key evil-insert-state-map (kbd "C-S-z") 'evil-mode-with-cursor)
  (define-key evil-visual-state-map (kbd "C-S-z") 'evil-mode-with-cursor)
  (define-key evil-motion-state-map (kbd "C-S-z") 'evil-mode-with-cursor)
  (define-key evil-emacs-state-map (kbd "C-S-z") 'evil-mode-with-cursor)
  (setq evil-emacs-state-cursor 'bar)

  (autoload 'evil-local-mode "evil" nil t)

  (defun evil-local-mode-with-cursor ()
    (interactive)
    (unless (boundp 'evil-local-mode)
      (evil-local-mode -1)) ;; unless part is for initialization
    (if evil-local-mode
	(progn (evil-local-mode -1)
	       (setq cursor-type 'bar))
      (evil-local-mode 1)))
#+END_SRC

* Pyim
ivy 支持拼音搜索
#+BEGIN_SRC emacs-lisp
  ;; @REF: https://emacs-china.org/t/ivy-read/2432/6?u=yongfeizhai
  (defun eh-ivy-cregexp (str)
    (if (eq 0 (length str))
        (ivy--regex-plus str)
      (concat
       (ivy--regex-plus str)
       "\\|"
       (pyim-cregexp-build str))))
#+END_SRC

* Rime
** switch between xhup & flypy
#+BEGIN_SRC emacs-lisp

(defvar rime--flypy-p nil
  "输入法默认的状态是小鹤双拼+posframe的显示格式")

(defun fei-toggle-xhup-flypy ()
  (interactive)
  (if (fboundp 'rime-lib-select-schema)
      (if rime--flypy-p
	  (progn (rime-lib-select-schema "double_pinyin_flypy")
		 (setq rime-show-candidate 'posframe)
		 (setq rime-show-preedit t)
		 (setq rime--flypy-p nil))
	(rime-lib-select-schema "flypy")
	(setq rime-show-candidate 'minibuffer)
	(setq rime-show-preedit 't)
	(setq rime--flypy-p t))
    (message "Rime has not been required")))

#+END_SRC

** 输入方案相关链接

小鹤双拼方案地址: https://github.com/cnfeat/Rime

小鹤音形方案地址: http://flypy.ys168.com/ 这个链接中的“小鹤音形挂
接第三方平台”文件夹linux对应的是macos，win10对应的就是win10

小鹤音形连写方案地址: https://github.com/brglng/rime-xhup

动态链接相关地址（Win10），Linux 不需要折腾，开箱即用

librime 动态链接下载地址：https://github.com/DogLooksGood/emacs-rime/issues/64#issuecomment-605436317

一些说明: 最近更新的 rime 需要重新编译 librime-emacs.dll，但我的
windows 编译环境没有配好，一直用的是上面链接提供的。目前发现一个
workaround: 修改 rime 源码相应部分，不让它重新编译。便采用了 submodule
的方法

** 这段代码是想要配置选中的项的高亮配色
还不知道是什么原因，下面的设置不能生效，保留是为了下次想追究方便回忆

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'rime-default-face nil :slant 'italic)
#+END_SRC

** rime mode line indicator 自己魔改的版本
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'rime
    ;; 下面的设置会覆盖默认信息，但我只是想添加这个指示信息，便有了
    ;; `fei-rime-lighter'，

    ;; (setq mode-line-mule-info '((:eval (rime-lighter))))

    (add-to-list 'mode-line-mule-info '((:eval (fei-rime-lighter))))
    (setq-default mode-line-mule-info mode-line-mule-info)

    (defun fei-rime-lighter ()
      "rewrite `rime-lighter' "
      (if (and (equal current-input-method "rime")
               (bound-and-true-p rime-mode))
          (if (and (rime--should-enable-p)
                   (not (rime--should-inline-ascii-p)))
              (propertize
               (char-to-string 12563)
               'face
               'rime-indicator-face)
            (propertize
             (char-to-string 12563)
             'face
             'rime-indicator-dim-face))
        ""))
    )
#+END_SRC

* Pyim
#+BEGIN_SRC emacs-lisp
  (pyim-isearch-mode t)
#+END_SRC

* EAF

不用的 EAF 模块
#+BEGIN_SRC emacs-lisp
  (require 'eaf-mail)
  (require 'eaf-camera)
  (require 'eaf-jupyter)
  (require 'eaf-netease-cloud-music)
  (require 'eaf-system-monitor)
  (require 'eaf-interleave)
  (require 'eaf-mindmap)

  (with-eval-after-load 'eaf

    (eaf-bind-key eaf-interleave-sync-next-note "M-n" eaf-pdf-viewer-keybinding)
    (eaf-bind-key eaf-interleave-sync-previous-note "M-p" eaf-pdf-viewer-keybinding)
    (eaf-bind-key eaf-interleave-open-notes-file "n" eaf-pdf-viewer-keybinding)
    (eaf-bind-key eaf-interleave-add-note "a" eaf-pdf-viewer-keybinding)
    (eaf-bind-key eaf-interleave-sync-current-note "s" eaf-pdf-viewer-keybinding)

    (define-key eaf-interleave-mode-map (kbd "M-n") 'eaf-interleave-sync-next-note)
    (define-key eaf-interleave-mode-map (kbd "M-p") 'eaf-interleave-sync-previous-note)

    )
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-hook 'server-after-make-frame-hook
	  (lambda () (when window-system (require 'init-eaf))))
#+END_SRC

不用 file-manager 了
#+BEGIN_SRC emacs-lisp
  (require 'eaf-file-manager)
  (setq eaf-file-manager-show-hidden-file nil)
  (fei-eaf-wrapper eaf-open-in-file-manager)
  (global-set-key (kbd "M-s e f") 'fei-eaf-open-in-file-manager)
#+END_SRC

不用 rss-reader 了
#+BEGIN_SRC emacs-lisp
  (require 'eaf-rss-reader)
  (setq eaf-rss-reader-web-page-other-window nil)
  (global-set-key (kbd "M-s e r") 'fei-eaf-open-rss-reader)
  (fei-eaf-wrapper eaf-open-rss-reader)
  (eaf-bind-key js_mark_article_as_read "b" eaf-rss-reader-keybinding)
#+END_SRC

不用 eaf-terminal 了
#+BEGIN_SRC emacs-lisp
  (require 'eaf-terminal)
  (defun fei-eaf-terminal-here ()
    (interactive)
    (eaf-terminal-run-command-in-dir "tmux" default-directory))
  (global-set-key (kbd "<s-return>") 'fei-eaf-terminal-here)

  (eaf-setq eaf-terminal-font-family "JetBrains Mono")
  ;; (eaf-setq eaf-terminal-font-family "Hack")
  (eaf-setq eaf-terminal-font-size "20")	;`eaf-setq' 已经过时了

  (eaf-bind-key nil "M-s" eaf-terminal-keybinding) ;default is `eaf-py-proxy-search_text_backward'
  (eaf-bind-key eaf-open-terminal "S" eaf-file-manager-keybinding)
#+END_SRC

* Keybindings
#+BEGIN_SRC emacs-lisp
  (with-eval-after-load 'matlab-mode
    (define-key matlab-mode-map (kbd "M-j") 'ivy-switch-buffer))

  (global-set-key (kbd "M-j") 'ivy-switch-buffer)

  (define-key ivy-minibuffer-map (kbd "M-j") (kbd "RET"))
  (define-key minibuffer-local-map (kbd "M-j") (kbd "RET"))
  (define-key minibuffer-local-map (kbd "M-h") (kbd "RET"))
#+END_SRC

* Ibuffer
从零开始是用 ibuffer ，备份一下之前的配置
#+BEGIN_SRC emacs-lisp
  (setq ibuffer-show-empty-filter-groups nil) ;; 不显示空组
  (setq ibuffer-movement-cycle nil)
  (add-hook 'ibuffer-mode-hook #'hl-line-mode)
  ;;; 2021-07-02: 小毛病终于解决了，见第6行的配置
  ;; (add-hook 'ibuffer-mode-hook #'ibuffer-auto-mode) 

  ;;; ibuffer group
  (setq ibuffer-saved-filter-groups
        '(("default"
           ("C/C++" (or (name . "^.*\\.c$")
                        (name . "^.*\\.cpp$")))
           ("Matlab" (name . "^.*\\.m$"))
           ("Lisp" (or (name . "^.*\\.el$")
                       (mode . emacs-lisp-mode)))
           ("EAF" (mode . eaf-mode))
           ("Org" (or (mode . org-mode)
                      (mode . org-agenda-mode)))
           ("Dired" (mode . dired-mode))
           ("Emacs" (or (mode . eshell-mode)
                        (name . "^\\*ielm\\*$")))
           ("PDF" (name . "^.*\\.pdf$"))
           ;; 下面这个是贪婪匹配，就是匹配 * 开头和结尾所有句子（包括空格）
           ("Files" (not (name . "^\\*.*\\*$")))
           )))
#+END_SRC

后来发现 ibuffer 一点也不常用
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-b") (li (ibuffer-jump) (ibuffer-auto-mode 1)))
  (global-set-key (kbd "C-x 4 C-b") (li (ibuffer-jump t) (ibuffer-auto-mode 1)))
#+END_SRC

* Windows
#+BEGIN_SRC emacs-lisp
  (defun other-window-backward ()
    (interactive)
    (other-window -1))

  (transient-command other-window (other-window 1)
    '(("o" . other-window)
      ("O" . other-window-backward)))

  (transient-command other-window-backward
    (other-window-backward)
    '(("o" . other-window)
      ("O" . other-window-backward)))
#+END_SRC

* Octave
#+BEGIN_SRC emacs-lisp
  (add-to-list 'auto-mode-alist '("\\.m\\'" . octave-mode))

  (add-hook 'octave-mode-hook
            (lambda ()
              (progn
                (setq octave-comment-char ?%)
                (setq comment-start "% ")
                (setq comment-add 0)
                (setq comment-column 0)
                )))
#+END_SRC

* Ivy-posframe
设置 ivy 相关的窗口显示的位置
#+BEGIN_SRC emacs-lisp
  (ivy-posframe-mode 1)

  (setq ivy-posframe-display-functions-alist
      '((t . ivy-posframe-display-at-frame-top-center)
        ))

  ;; (setq ivy-posframe-display-functions-alist
  ;;     '((swiper . ivy-posframe-display-at-frame-bottom-window-center)
  ;;       (complete-symbol . ivy-posframe-display-at-point)
  ;;       (counsel-M-x . ivy-posframe-display-at-frame-center)
  ;;       (counsel-find-file . ivy-posframe-display-at-frame-center)
  ;;       (ivy-switch-buffer . ivy-posframe-display-at-frame-center)))
#+END_SRC

* Encode
只有在 Windows 平台才会出现编码问题
#+BEGIN_SRC emacs-lisp
  ;; 此配置会导致在菜单栏选字体的时候出现乱码
  ;; (setq locale-coding-system   'utf-8)    ; pretty
  ;; (set-selection-coding-system 'utf-8)    ; please
  ;; 问题：
  ;; 这个命令会导致 emacsclient 出现编码问题(win10)：
  ;; 终端命令 ec file.name 会出现文件名乱码
  ;; (prefer-coding-system        'utf-8)    ; with sugar on top
  ;; (setq default-process-coding-system '(utf-8 . utf-8))
#+END_SRC

* Paredit
#+BEGIN_SRC emacs-lisp

  ;; (add-hook 'emacs-lisp-mode-hook 'paredit-mode)
  (with-eval-after-load 'paredit
    (define-key paredit-mode-map (kbd "M-s") nil)
    (define-key paredit-mode-map (kbd "M-r") nil)
    (define-key paredit-mode-map (kbd "M-R") #'paredit-splice-sexp)
    )

#+END_SRC

* VC
emacs28 自带的 `project-vc-dir' 已经可以替代这个函数了，而且处理得更好
#+BEGIN_SRC emacs-lisp
(defun fei-vc-dired-jump (arg)
  (interactive "P")
  (let ((target-dir (or (vc-root-dir)
                        default-directory)))
    (vc-dir target-dir))
  )
#+END_SRC

